<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开悟初赛笔记-特征处理篇</title>
      <link href="/2025/07/26/%E6%95%99%E7%A8%8B/%E5%88%9D%E8%B5%9B%E7%AC%94%E8%AE%B0-%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86%E7%AF%87/"/>
      <url>/2025/07/26/%E6%95%99%E7%A8%8B/%E5%88%9D%E8%B5%9B%E7%AC%94%E8%AE%B0-%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="开悟初赛笔记-特征处理篇">开悟初赛笔记-特征处理篇</h1><p>本次开悟初赛期对于特征的处理要求有一点高，而且不同赛道的赛道地图和特征信息都不大相同。</p><p>比如博弈赛道的地图里面英雄的局部视野域都是11 x 11的矩阵，在具身赛道里面的地图英雄的局部视野域就变成了51 x 51的矩阵了。</p><p>不同的局部视野域做特征输入需要就特征的维度长度来进行不同的模型设计，而且不同赛道也需要采取不同的特征设计。</p><p><strong>比如具身赛道的51 x51展平之后维度过于庞大，应当先做卷积处理，而博弈赛道的话没必要特意做卷积处理，用MLP即可，还有博弈的中级和高级赛道的organs字段里面是不一样的，具身的话基本只存在视野域内的organ。</strong></p><p>以及官方默认提供的模型输出之后的维度仅仅只有移动的八维，闪现的八维是没有进行提供的。</p><p>这会导致智能体在面对这种有随机障碍物的环境很难去到达终点，<strong>所以我们做的第一步是做模型输出的动作空间进行扩展</strong>。</p><p><strong>注：本人也是在历史各位大佬的帖子里面不断学习成长过来的，初赛的话发这个帖子是希望无论是新来参加开悟的还是以前一起的都能够一起讨论学习，我已经参加了大概三年开悟比赛了，从一开始的小白完全不懂，到现在也能够自己发帖帮助一些萌新。我的话不在乎成绩，我很珍惜和各位学习的这些时间。</strong></p><h2 id="一先让模型学会闪现">一、先让模型学会闪现！</h2><p>初赛的环境障碍物是随机的，为了能够让智能体快速到达终点，闪现的动作是必须的。</p><p>具体的修改是扩展动作维度从原来的8维扩展到16维</p><p>具体的修改是在<strong>feature</strong>文件夹下的<strong>preprocessor.py</strong>文件里面，里面包含了关于特征处理的所有部分，默认特征处理函数接受到的参数是frame_state，里面包含了obs和extra_info参数，<strong>extra_info在特征处理是不允许使用的，但是奖励设计是可以参与的。</strong>因为每次进行评估的过程中，extra_info是空的，但是训练阶段extra_info是可以取到的，所以可以利用奖励设计。</p><p><strong>闪现的具体修改细节如下</strong>：</p><ul><li>修改preprocessor.py里面 Preprocessor类的初始化</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Preprocessor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 从8修改成16，代表8个移动维度，8个闪现维度</span></span><br><span class="line">        <span class="variable language_">self</span>.move_action_num = <span class="number">16</span></span><br><span class="line">        <span class="variable language_">self</span>.reset()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 闪现是否可用 </span></span><br><span class="line">        <span class="variable language_">self</span>.is_flashed = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pb2struct</span>(<span class="params">self, frame_state, last_action</span>):</span><br><span class="line">        obs, _ = frame_state</span><br><span class="line">        <span class="variable language_">self</span>.step_no = obs[<span class="string">&quot;frame_state&quot;</span>][<span class="string">&quot;step_no&quot;</span>]</span><br><span class="line"></span><br><span class="line">        hero = obs[<span class="string">&quot;frame_state&quot;</span>][<span class="string">&quot;heroes&quot;</span>][<span class="number">0</span>]</span><br><span class="line">        map_info = obs[<span class="string">&quot;map_info&quot;</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 闪现是否可用 -- 新增一个字段来代表闪现是否可用，默认初始化的时候可以为True</span></span><br><span class="line">        <span class="keyword">if</span> hero[<span class="string">&#x27;talent&#x27;</span>][<span class="string">&#x27;status&#x27;</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.is_flashed = <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>然后在官方提供的获取合法动作的函数里面加入最新的闪现的8个合法动作维度</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_legal_action</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># if last_action is move and current position is the same as last position, add this action to bad_move_ids</span></span><br><span class="line">        <span class="comment"># 如果上一步的动作是移动，且当前位置与上一步位置相同，则将该动作加入到bad_move_ids中</span></span><br><span class="line"></span><br><span class="line">        legal_action = [<span class="literal">False</span>] * <span class="variable language_">self</span>.move_action_num</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加闪现的合法性</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_flashed:</span><br><span class="line">            legal_action[<span class="number">8</span>:] = [<span class="literal">True</span>] * <span class="number">8</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            legal_action[<span class="number">8</span>:] = [<span class="literal">False</span>] * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="built_in">abs</span>(<span class="variable language_">self</span>.cur_pos_norm[<span class="number">0</span>] - <span class="variable language_">self</span>.last_pos_norm[<span class="number">0</span>]) &lt; <span class="number">0.001</span></span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">abs</span>(<span class="variable language_">self</span>.cur_pos_norm[<span class="number">1</span>] - <span class="variable language_">self</span>.last_pos_norm[<span class="number">1</span>]) &lt; <span class="number">0.001</span></span><br><span class="line">            <span class="keyword">and</span> <span class="variable language_">self</span>.last_action &gt; -<span class="number">1</span></span><br><span class="line">        ):</span><br><span class="line">            <span class="variable language_">self</span>.bad_move_ids.add(<span class="variable language_">self</span>.last_action)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.bad_move_ids = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        legal_action = [<span class="variable language_">self</span>.move_usable] * <span class="variable language_">self</span>.move_action_num</span><br><span class="line">        <span class="keyword">for</span> move_id <span class="keyword">in</span> <span class="variable language_">self</span>.bad_move_ids:</span><br><span class="line">            legal_action[move_id] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.move_usable <span class="keyword">not</span> <span class="keyword">in</span> legal_action:</span><br><span class="line">            <span class="variable language_">self</span>.bad_move_ids = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">return</span> [<span class="variable language_">self</span>.move_usable] * <span class="variable language_">self</span>.move_action_num</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> legal_action</span><br></pre></td></tr></table></figure><ul><li>修改conf.py的配置文件</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="comment"># actions</span></span><br><span class="line">    <span class="comment"># 动作</span></span><br><span class="line">    ACTION_LEN = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 8个移动方向 + 8个闪现方向</span></span><br><span class="line">    ACTION_NUM = <span class="number">8</span> + <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># features</span></span><br><span class="line">    <span class="comment"># 特征</span></span><br><span class="line">    FEATURES = [</span><br><span class="line">        <span class="comment">#2 当前位置的归一化</span></span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="comment">#6 归一化的终点位置特征</span></span><br><span class="line">        <span class="number">6</span>,</span><br><span class="line">        <span class="comment">#6 归一化的历史位置特征</span></span><br><span class="line">        <span class="number">6</span>,</span><br><span class="line">        <span class="comment">#16维 移动8方向的合法动作，闪现8方向的合法动作</span></span><br><span class="line">        <span class="number">8</span> + <span class="number">8</span>,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>通过这些基础的修改和官方默认的奖励，最终应该可以然后训练的胜率（监控指标的diy_1）可以稳定在0.98-0.99左右徘徊，基本稳定接近到1.0</p><h2 id="二其他特征解析">二、其他特征解析</h2><p>关于其他的特征，我们可以通过详细分析下官方的obs参数里面有什么</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Observation &#123;</span><br><span class="line">  FrameState frame_state = 1;     // 局部环境数据</span><br><span class="line">  ScoreInfo score_info = 2;       // 得分信息</span><br><span class="line">  repeated MapInfo map_info = 3;  // 局部地图信息</span><br><span class="line">  repeated int32 legal_act = 4;   // 合法动作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FrameState &#123;</span><br><span class="line">  int32 step_no = 1;             // 步数</span><br><span class="line">  repeated RealmHero heroes = 2;  // 英雄状态</span><br><span class="line">  repeated RealmOrgan organs = 3; // 物件状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ScoreInfo &#123;</span><br><span class="line">  float score = 1;                    // 即时得分</span><br><span class="line">  float total_score = 2;              // 总得分</span><br><span class="line">  int32 step_no = 3;                  // 步号</span><br><span class="line">  int32 treasure_collected_count = 4; // 收集到的宝箱数量</span><br><span class="line">  int32 treasure_score = 5;           // 收集到的宝箱得分</span><br><span class="line">  int32 buff_count = 6;              // 收集到的buff数量</span><br><span class="line">  int32 talent_count = 7;            // 使用技能的数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RealmOrgan &#123;</span><br><span class="line">  int32 sub_type = 1; // 物件类型，1代表宝箱, 2代表加速buff,3代表起点,4代表终点</span><br><span class="line">  int32 config_id = 2; // 物件id 0代表buff，1~13代表宝箱 21代表起点, 22代表终点</span><br><span class="line">  int32 status = 3; // 0表示不可获取，1表示可获取, -1表示视野外</span><br><span class="line">  Position pos = 4; // 物件位置坐标</span><br><span class="line">  int32 cooldown = 5;                // 物件剩余冷却时间</span><br><span class="line">  RelativePosition relative_pos = 6; // 物件相对位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#其中0表示不可通行，1表示可以通行，2表示起点位置，3表示终点位置，4表示宝箱位置，6表示加速增益位置。</span><br><span class="line">message MapInfo &#123;</span><br><span class="line">  repeated int32 values = 1; // 地图信息行信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面官方给出的数据协议，我们其实可以设计如下几个基础的特征，可能可以一定程度上提高模型的性能。</p><ul><li>智能体的局部视野域</li></ul><p>智能体的局部视野域的设计可以利用obs参数里面的map_info进行设计，而且我们已知的是地图里面有不同的数字表示不同的视野信息，我们可以把它分割成对应四个视野域信息</p><p><strong>注：演示的是博弈赛道里面的，具身赛道请根据自己赛道的情况去设计视野域的大小，具身是51x 51</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其中0表示不可通行，1表示可以通行，2表示起点位置，3表示终点位置，4表示宝箱位置，6表示加速增益位置。</span></span><br><span class="line">treasure_map = np.zeros((<span class="number">11</span>, <span class="number">11</span>), dtype=np.float32)</span><br><span class="line">end_map = np.zeros((<span class="number">11</span>, <span class="number">11</span>), dtype=np.float32)</span><br><span class="line">obstacle_map = np.zeros((<span class="number">11</span>, <span class="number">11</span>), dtype=np.float32)</span><br><span class="line">buff_map = np.zeros((<span class="number">11</span>, <span class="number">11</span>), dtype=np.float32)</span><br><span class="line"><span class="comment"># 遍历 map_info 并填充矩阵</span></span><br><span class="line"><span class="keyword">for</span> r, row_data <span class="keyword">in</span> <span class="built_in">enumerate</span>(map_info):</span><br><span class="line">    <span class="keyword">for</span> c, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(row_data[<span class="string">&#x27;values&#x27;</span>]):</span><br><span class="line">        <span class="comment"># 宝箱</span></span><br><span class="line">        <span class="keyword">if</span> value == <span class="number">4</span>:</span><br><span class="line">            treasure_map[r, c] = <span class="number">1.0</span></span><br><span class="line">        <span class="comment"># 终点</span></span><br><span class="line">        <span class="keyword">elif</span> value == <span class="number">3</span>:</span><br><span class="line">            end_map[r, c] = <span class="number">1.0</span></span><br><span class="line">        <span class="comment"># 障碍物</span></span><br><span class="line">        <span class="keyword">elif</span> value == <span class="number">0</span>:</span><br><span class="line">            obstacle_map[r, c] = <span class="number">1.0</span></span><br><span class="line">        <span class="comment"># 加速增益</span></span><br><span class="line">        <span class="keyword">elif</span> value == <span class="number">6</span>:</span><br><span class="line">            buff_map[r, c] = <span class="number">1.0</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 展平所有矩阵</span></span><br><span class="line"><span class="variable language_">self</span>.treasure_flag = treasure_map.flatten()</span><br><span class="line"><span class="variable language_">self</span>.end_flag = end_map.flatten()</span><br><span class="line"><span class="variable language_">self</span>.obstacle_flag = obstacle_map.flatten()</span><br><span class="line"><span class="variable language_">self</span>.buff_flag = buff_map.flatten()     </span><br></pre></td></tr></table></figure><p>另外的，虽然官方没有给出对应的记忆矩阵视野域，但是我们其实可以自己去根据每次的位置去做更新自己设计一个记忆矩阵的视野域。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先一样的初始化</span></span><br><span class="line"><span class="variable language_">self</span>.global_memory_map = np.zeros((<span class="number">128</span>,<span class="number">128</span>), dtype=np.float32)</span><br><span class="line"><span class="variable language_">self</span>.local_memory_map = np.zeros((<span class="number">11</span>,<span class="number">11</span>), dtype=np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记忆矩阵的更新函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">memory_update</span>(<span class="params">self, cur_pos</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    记忆矩阵更新</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 全局记忆矩阵</span></span><br><span class="line">    x,z = cur_pos</span><br><span class="line">    z = <span class="number">127</span> - z</span><br><span class="line">    current_value = <span class="variable language_">self</span>.global_memory_map[z, x]</span><br><span class="line">    <span class="variable language_">self</span>.global_memory_map[z, x] = <span class="built_in">min</span>(<span class="number">1.0</span>, current_value + <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 局部记忆矩阵</span></span><br><span class="line">    <span class="comment"># 计算在全局地图上的源区域边界</span></span><br><span class="line">    src_top = <span class="built_in">max</span>(<span class="number">0</span>, z - <span class="number">5</span>)</span><br><span class="line">    src_bottom = <span class="built_in">min</span>(<span class="number">128</span>, z + <span class="number">6</span>)</span><br><span class="line">    src_left = <span class="built_in">max</span>(<span class="number">0</span>, x - <span class="number">5</span>)</span><br><span class="line">    src_right = <span class="built_in">min</span>(<span class="number">128</span>, x + <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算在局部地图上的目标区域边界</span></span><br><span class="line">    dst_top = src_top - (z - <span class="number">5</span>)</span><br><span class="line">    dst_bottom = src_bottom - (z - <span class="number">5</span>)</span><br><span class="line">    dst_left = src_left - (x - <span class="number">5</span>)</span><br><span class="line">    dst_right = src_right - (x - <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从全局地图复制有效区域到局部地图</span></span><br><span class="line">    <span class="variable language_">self</span>.local_memory_map[dst_top:dst_bottom, dst_left:dst_right] = <span class="variable language_">self</span>.global_memory_map[src_top:src_bottom, src_left:src_right]</span><br><span class="line">    <span class="variable language_">self</span>.memory_flag = <span class="variable language_">self</span>.local_memory_map.flatten()</span><br></pre></td></tr></table></figure><ul><li>智能体当前的organs状态列表</li></ul><p>对于organs状态的信息，我们可以先默认初始化13个随机宝箱的环境，让所有的宝箱都能够在状态里面显示出来，这些在extra_info里面可以详细看到。</p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202507261644303.png" /></p><p><strong>我们统一能看到且能收集是状态1、不能看到不能收集是状态0</strong></p><p>我们先默认初始化15维度的organs状态列表，代表的是对应15个organ的状态，包括BUFF、宝箱、终点（默认14、方便设计）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历更新宝箱终点和BUFF视野内状态，0是不可见，1是可见</span></span><br><span class="line"><span class="keyword">for</span> target <span class="keyword">in</span> <span class="variable language_">self</span>.target_states:</span><br><span class="line">    <span class="keyword">if</span> target[<span class="string">&#x27;type&#x27;</span>] != <span class="string">&quot;end&quot;</span>:</span><br><span class="line">        <span class="variable language_">self</span>.organs_states[target[<span class="string">&#x27;config_id&#x27;</span>]] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="variable language_">self</span>.organs_states[<span class="number">14</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面的设计对于博弈赛道还是具身赛道通用，我这边是做过特殊处理过的，其实默认的organs里面的也可以直接用，根据type去判断是否是宝箱还是终点。</p><ul><li>当前智能体所能得到的目标特征</li></ul><p>关于这个特征的设计，要区分下不同赛道的设计特点。</p><p><strong>对于博弈中级赛道</strong>：其实目标是非常明确的，因为obs里面是基本无论是位置信息，还有所有的organ信息基本很全</p><p><strong>对于博弈高级赛道：</strong>目标的明确性稍差，位置信息不提供，organ信息也基本很全，官方提供了大概的位置计算公式。</p><p><strong>对于具身赛道：</strong>目标明确性非常差，位置信息提供，organ信息不全，官方默认提供了<code>self.target_pos_list = [(26, 87), (85, 114), (32, 24), (101, 40), (59, 64)]</code>用于探索，可以作为探索目标进行保留作为特征设计。</p><p>对于博弈中级赛道的设计，直接获取对应最短曼哈顿距离的作为目标即可，然后宝箱收集完之后再转目标为终点这个特殊目标。然后默认终点位置不明确可以直接利用官方默认提供的大概估算位置的方法，其他也适用的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if end_pos is not found, use relative position to predict end_pos</span></span><br><span class="line"><span class="comment"># 如果终点位置未找到，使用相对位置预测终点位置</span></span><br><span class="line"><span class="keyword">elif</span> (<span class="keyword">not</span> <span class="variable language_">self</span>.is_end_pos_found) <span class="keyword">and</span> (</span><br><span class="line">    <span class="variable language_">self</span>.end_pos <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">or</span> <span class="variable language_">self</span>.cur_step_no % <span class="number">100</span> == <span class="number">0</span></span><br><span class="line">    <span class="keyword">or</span> <span class="variable language_">self</span>.end_pos_dir != end_pos_dir</span><br><span class="line">    <span class="keyword">or</span> <span class="variable language_">self</span>.end_pos_dis != end_pos_dis</span><br><span class="line">):</span><br><span class="line">    <span class="comment"># 计算距离</span></span><br><span class="line">    distance = end_pos_dis * <span class="number">20</span></span><br><span class="line">    <span class="comment"># 计算角度</span></span><br><span class="line">    theta = DirectionAngles[end_pos_dir]</span><br><span class="line">    <span class="comment"># 计算位置偏移</span></span><br><span class="line">    delta_x = distance * math.cos(math.radians(theta))</span><br><span class="line">    delta_z = distance * math.sin(math.radians(theta))</span><br><span class="line">    <span class="comment"># 更新终点位置</span></span><br><span class="line">    <span class="variable language_">self</span>.end_pos = (</span><br><span class="line">        <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(<span class="number">128</span>, <span class="built_in">round</span>(<span class="variable language_">self</span>.cur_pos[<span class="number">0</span>] + delta_x))),</span><br><span class="line">        <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(<span class="number">128</span>, <span class="built_in">round</span>(<span class="variable language_">self</span>.cur_pos[<span class="number">1</span>] + delta_z))),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.end_pos_dir = end_pos_dir</span><br><span class="line">    <span class="variable language_">self</span>.end_pos_dis = end_pos_dis</span><br></pre></td></tr></table></figure><p>对于博弈高级赛道的设计，位置不明确就大概估算位置，明确就直接用明确的位置信息，一样的和博弈中级赛道取对应最短曼哈顿距离作为目标即可。</p><p>对于具身赛达的设计，我们可以先看看能否获取到对应的当前视野的最短距离目标，如果获取不到就转探索目标，然后要时刻记录历史探索到的目标进行存储，方便后面进行优先级的目标切换。在弄个保险的避免目标完全丢失，以自己的位置为目标，不过优先级最低。</p><p><strong>对于具身赛道的设计我需要额外说明这个目标的优先级，以及提供多历史目标进入特征，我目前还在尝试，不过目前效果好像还是积极的，我这边分享出来各位可以评判下再试着用用。</strong></p><p>具身赛道的目标优先级是这样的</p><ul><li>最高优先级：视野内已有的最短目标</li><li>高优先级：记忆内的最短宝箱目标</li><li>中优先级：探索优先级</li><li>特殊优先级（中后面）：终点目标，终点目标的话也是需要不断探索才能找到，为什么比探索目标优先级低，是为了防止遗漏宝箱。</li><li>低优先级：以自己的位置为目标，”哑“目标。</li></ul><p>最终所以赛道得到的目标经过官方提供的目标特征的函数处理完之后加入到特征里面即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.feature_target_pos = <span class="variable language_">self</span>._get_pos_feature(<span class="variable language_">self</span>.target[<span class="string">&#x27;state&#x27;</span>] != -<span class="number">1</span>, <span class="variable language_">self</span>.cur_pos, <span class="variable language_">self</span>.target[<span class="string">&#x27;pos&#x27;</span>])   </span><br></pre></td></tr></table></figure><p><strong>注：具身赛道和其他赛道其他也可以尝试加入候选目标，所以维度可以是(1+候选目标数量)x6</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取新的多目标特征 -- 具身赛道的候选依赖于历史探索到的目标</span></span><br><span class="line">multi_target_features = <span class="variable language_">self</span>._get_multi_target_features(K=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li>当前位置的one-hot编码特征</li></ul><p>这个的话我早期没有加的，因为之前的比赛代码里面是有的，所以我后面也加上了，其实这个特征处理也非常简单，可以参考如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 目标位置的one-hot编码</span></span><br><span class="line">pos_row = [<span class="number">0</span>] * <span class="number">128</span></span><br><span class="line">pos_row[<span class="variable language_">self</span>.cur_pos[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line">pos_col = [<span class="number">0</span>] * <span class="number">128</span></span><br><span class="line">pos_col[<span class="variable language_">self</span>.cur_pos[<span class="number">1</span>]] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>所以我最终的特征总维度大概如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># features</span></span><br><span class="line"><span class="comment"># 特征</span></span><br><span class="line">FEATURES = [</span><br><span class="line"><span class="comment"># 当前位置归一化</span></span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="comment"># 当前位置的one-hot编码</span></span><br><span class="line">    <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>,</span><br><span class="line">    <span class="comment"># 15个物件的状态列表</span></span><br><span class="line">    <span class="number">15</span>,</span><br><span class="line">    <span class="comment"># 目标的位置特征，（允许加入候选目标）</span></span><br><span class="line">    <span class="number">6</span> * <span class="number">3</span>,</span><br><span class="line">    <span class="comment"># 历史位置特征</span></span><br><span class="line">    <span class="number">6</span>,</span><br><span class="line">    <span class="comment"># 16个合法动作</span></span><br><span class="line">    <span class="number">8</span> + <span class="number">8</span>,</span><br><span class="line">    <span class="comment"># 5个局部视野域- 宝箱、障碍物、BUFF、终点、记忆矩阵</span></span><br><span class="line">    <span class="number">5</span>*<span class="number">51</span>*<span class="number">51</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 腾讯开悟 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025开悟学习期笔记</title>
      <link href="/2025/07/16/%E6%95%99%E7%A8%8B/2025%E5%BC%80%E6%82%9F%E5%AD%A6%E4%B9%A0%E6%9C%9F%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/07/16/%E6%95%99%E7%A8%8B/2025%E5%BC%80%E6%82%9F%E5%AD%A6%E4%B9%A0%E6%9C%9F%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="开悟学习期思路分享">开悟学习期思路分享</h1><h2 id="一问题分析">一、问题分析</h2><p>学习期的比赛环境是一个智能体在64x64的网格环境里面，宝箱是0-10的随机，位置也是随机的。比赛目的是为了能够让其在对地图不断地探索中学习移动策略，减少碰撞障碍物，以最少的步数<strong>从起点走到终点</strong>，可能会有附属任务——<strong>收集宝箱</strong>。</p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202507110057765.png" /></p><p>我们不妨把这个问题简化，我们把宝箱和终点都视为<strong>目标</strong>、终点可以看成一个<strong>特殊的目标</strong>。实际任务的本质就是</p><p><strong>在这随机的目标（包括终点）里面，让智能体每次都走最近的目标，最后再到我们终点这个特殊目标</strong></p><p>这样我们就可以把这个稍微复杂的问题分解成一个个小问题，无论在随机多少宝箱的环境，我们都能把它分解成每次都是<strong>以当前的位置到最近的目标的位置</strong></p><p>比如官方的这个示例图，我们就可以把它分解成6个任务。我们用红色箭头来标识如下图</p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202507102334311.png" /></p><p>在当前的这个环境里面，我们有6个任务目标，其实不难发现，任务目标数和宝箱数量成正比，并且是宝箱数量+1。其实我们目的就是要让智能体学会的是在面对每次大环境里面的一次次的简单任务。而且不难发现这个<strong>任务数量是固定的</strong>。其实这个<strong>环境的所有随机也都不是真的随机，我们智能体一共只会遇到大概1024个环境。</strong></p><h2 id="二特征处理">二、特征处理</h2><p>特征处理可以直接在原本Q-learning的基础上做微改下就行，比如我的特征处理就是把Q-learning里面的state换成了智能体当前的坐标，然后有一部分做了简单的归一化</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 特征#1: 归一化坐标</span></span><br><span class="line">norm_pos = [pos[<span class="number">0</span>] / <span class="number">64.0</span>, pos[<span class="number">1</span>] / <span class="number">64.0</span>]</span><br><span class="line"><span class="comment"># 特征#3: 智能体当前位置相对于终点和宝箱的距离(离散化)</span></span><br><span class="line">end_treasure_dists = raw_obs[<span class="string">&quot;feature&quot;</span>]</span><br><span class="line">end_treasure_dists = [state / <span class="number">6.0</span> <span class="keyword">for</span> state <span class="keyword">in</span> end_treasure_dists]</span><br></pre></td></tr></table></figure><h2 id="三模型和算法">三、模型和算法</h2><p>可以参考Pytorch官方的DQN教程：<ahref="https://pytorch.ac.cn/tutorials/intermediate/reinforcement_q_learning.html">强化学习(DQN) 教程 — PyTorch 教程 2.7.0+cu126 文档 - PyTorch 深度学习库</a></p><p>除此之外DQN还有很多变体，我这边采用的是<strong>Dueling_DQN</strong>和 <strong>Double_DQN</strong>。除此之外还有、Noisy_Dqn、PPO等等。</p><p><strong>强烈推荐Double DQN，这个是训练最稳定的，可以解决目标 Q值的计算可能导致过度估计的问题</strong>。</p><p>Double_DQN下的目标Q值变化：</p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202507122046892.png" /></p><p>其他的：</p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202507122048942.png" /></p><p>模型设计不需要搞得太花里胡哨了，卷积处理前面特征处理之后的4x5x5的矩阵图，将其他的和卷积处理展平之后的合并再经过全连接用Linear即可。我最终模型的大小是2.11MB。</p><h2 id="四奖励设计">四、奖励设计</h2><p><strong>奖励设计才是本次比赛最重要的部分</strong>，也是强化学习最具有特色的地方。没有了好的奖励设计，智能体就好比自然环境没有被训练过的野马。</p><p>奖励设计我们可以考虑有<strong>课程学习</strong>的思路，这个推荐可以看看P佬之前分享过的教程，给了我很大的启发。<ahref="https://aiarena.tencent.com/community/d/542-jing-hua-tie-hai-xuan-jie-duan-xing-zong-jie">P佬去年的经验贴</a></p><p>我这边说下奖励设计需要额外注意的地方，P佬在教程里面提到过以稠密奖励为骨，稀疏奖励为翼。前者更加重要，也需要思考如何设计。</p><p><strong>1、智能体刷奖励</strong></p><ul><li><p>比如这次环境我们要引导智能体靠近当前的最近目标，我们可能常规的想法是智能体只要靠近了目标，奖励就+1。但是其实我们可能忽略了一个很重要的问题，智能体会通过我们这个设计去刷奖励，比如先靠近+1，后远离+0，然后再靠近+1。所以我们应当平衡这个关系，不能让其刷分。</p></li><li><p>方案一：设计奖励可以靠近+1，远离-1，不动+0（需要额外惩罚约束）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reward += (prev_dist - cur_dist) * dist_reward</span><br></pre></td></tr></table></figure></li><li><p>方案二：设计记忆数组，不让刷分，记忆数组里面只允许每次都是最近的。<strong>键值最好用离散距离</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delta = prev_dist - cur_dist</span><br><span class="line"><span class="keyword">if</span> delta &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> memory_dist.get(cur_dist):</span><br><span class="line">    keys = memory_dist.keys()</span><br><span class="line">    <span class="keyword">if</span> keys:</span><br><span class="line">        min_key = <span class="built_in">min</span>(keys)</span><br><span class="line">        <span class="keyword">if</span> _end_dist &lt; min_key:</span><br><span class="line">            memory_dist[cur_dist] = <span class="literal">True</span></span><br><span class="line">            reward += delta * dist_reward</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        memory_dist[cur_dist] = <span class="literal">True</span></span><br><span class="line">        reward += delta * dist_reward</span><br></pre></td></tr></table></figure></li></ul><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202507110012328.png" /></p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202507110012009.png" /></p><p><strong>2、智能体目标不一致</strong></p><ul><li>比如考虑每次到目标位置的时候，我们的目标会进行更换，更换之后就会导致目标不唯一。采用这个设计的话，需要保证每次智能体都是<strong>唯一目标</strong>，不要出现多目标</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> prev_id == cur_id</span><br><span class="line"><span class="comment"># 实现奖励逻辑</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202507110017805.png" /></p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202507110017726.png" /></p><h2 id="五分布式训练">五、分布式训练</h2><p>建议参考以前的文档，或者可以参考以前一个佬开源的当时比赛代码，里面包含原来官方的分布式代码设计。</p><p>以前文档的地址：<ahref="https://doc.aiarena.tencent.com/competition/back_to_the_realm/1.0.0/guidebook/code-guide/">去年的文档</a></p><p>仓库地址：<ahref="https://github.com/wty-yy/kaiwu2024_taichu">Github-去年代码和大佬的分享</a></p><p>分布式训练我这边没有用attach装饰器，我直接写好对应的SampleData2NumpyData,、NumpyData2SampleData然后强行替换分布式框架里面的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SampleData = create_cls(<span class="string">&quot;SampleData&quot;</span>, state=<span class="literal">None</span>, next_state=<span class="literal">None</span>, action=<span class="literal">None</span>, leg_act=<span class="literal">None</span>, next_leg_act=<span class="literal">None</span>, reward=<span class="literal">None</span>, done=<span class="literal">None</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SampleData2NumpyData</span>(<span class="params">g_data</span>):</span><br><span class="line">    <span class="keyword">return</span> np.hstack(</span><br><span class="line">        (</span><br><span class="line">            np.array(g_data.state, dtype=np.float32),</span><br><span class="line">            np.array(g_data.next_state, dtype=np.float32),</span><br><span class="line">            np.array(g_data.action, dtype=np.float32),</span><br><span class="line">            np.array(g_data.leg_act, dtype=np.float32),</span><br><span class="line">            np.array(g_data.next_leg_act, dtype=np.float32),</span><br><span class="line">            np.array(g_data.reward, dtype=np.float32),</span><br><span class="line">            np.array(g_data.done, dtype=np.float32),</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">NumpyData2SampleData</span>(<span class="params">s_data</span>):</span><br><span class="line">    <span class="comment"># 根据维度定义进行正确切片: state=250, next_state=250, action=1, leg_act = 4, next_leg_act = 4, reward = 1, done = 1</span></span><br><span class="line">    <span class="keyword">return</span> SampleData(</span><br><span class="line">        state=s_data[<span class="number">0</span>:<span class="number">251</span>],</span><br><span class="line">        next_state=s_data[<span class="number">251</span>:<span class="number">502</span>],</span><br><span class="line">        action=s_data[<span class="number">502</span>],</span><br><span class="line">        leg_act=s_data[<span class="number">503</span>:<span class="number">503</span>+<span class="number">4</span>],  <span class="comment"># 4个动作</span></span><br><span class="line">        next_leg_act=s_data[<span class="number">503</span>+<span class="number">4</span>:<span class="number">507</span>+<span class="number">4</span>],  <span class="comment"># 4个动作</span></span><br><span class="line">        reward=s_data[-<span class="number">2</span>],</span><br><span class="line">        done=s_data[-<span class="number">1</span>],</span><br><span class="line">    )</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>只需要在definition.py里面完成上面对应的代码，然后将下面的这个代码应用到workflow.py和agent.py里面即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kaiwu_agent.agent.protocol.protocol <span class="keyword">as</span> protocol</span><br><span class="line"><span class="keyword">from</span> agent_diy.feature.definition <span class="keyword">import</span> SampleData2NumpyData, NumpyData2SampleData</span><br><span class="line">protocol.SampleData2NumpyData = SampleData2NumpyData</span><br><span class="line">protocol.NumpyData2SampleData = NumpyData2SampleData</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 腾讯开悟 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式课程设计</title>
      <link href="/2025/06/10/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E8%AE%BE/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AF%BE%E8%AE%BE/"/>
      <url>/2025/06/10/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E8%AE%BE/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式课程设计">嵌入式课程设计</h1><h3 id="项目概述">项目概述</h3><p>本项目是长江大学的嵌入式系统课程设计，包含了三个课设需要完成的任务内容，专为对应实验箱中的ARMCortex-A8开发板设计：</p><ol type="1"><li><strong>逆序流水灯控制</strong> - GPIO硬件控制演示</li><li><strong>SQLite数据库操作</strong> - 嵌入式数据库应用</li><li><strong>Qt图形界面LED控制</strong> - 跨平台GUI应用</li></ol><h3 id="功能特性">功能特性</h3><h4 id="逆序流水灯">逆序流水灯</h4><ul><li>8个LED灯的逆序流水效果</li><li>直接GPIO寄存器操作</li><li>内存映射硬件控制</li><li>实时控制台输出</li></ul><h4 id="sqlite数据库">SQLite数据库</h4><ul><li>完整的CRUD操作演示</li><li>交互式命令行界面</li><li>批量数据操作</li><li>错误处理和恢复</li></ul><h4 id="qt-gui控制面板">Qt GUI控制面板</h4><ul><li>直观的LED控制界面</li><li>实时硬件状态反馈</li><li>中文界面支持</li><li>一键全部控制功能</li></ul><h3 id="系统架构">系统架构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">嵌入式课设/</span><br><span class="line">├── 逆序流水灯/          # LED流水灯控制模块</span><br><span class="line">│   ├── src/</span><br><span class="line">│   │   └── led8.c       # 主程序和GPIO控制</span><br><span class="line">│   ├── include/</span><br><span class="line">│   │   └── led8.h       # 硬件定义和函数声明</span><br><span class="line">│   ├── build_arm.sh     # ARM交叉编译脚本</span><br><span class="line">│   └── CMakeLists.txt   # CMake构建配置</span><br><span class="line">├── 数据库/              # SQLite数据库模块</span><br><span class="line">│   ├── src/</span><br><span class="line">│   │   ├── main.c       # 主程序和菜单系统</span><br><span class="line">│   │   ├── sqlite_demo.c # 数据库操作实现</span><br><span class="line">│   │   └── sqlite3.c    # SQLite源码</span><br><span class="line">│   ├── include/</span><br><span class="line">│   │   ├── sqlite_demo.h</span><br><span class="line">│   │   └── sqlite3.h</span><br><span class="line">│   └── build_arm.sh</span><br><span class="line">├── QT/                  # Qt图形界面模块</span><br><span class="line">│   ├── src/</span><br><span class="line">│   │   └── main.cpp     # Qt应用程序</span><br><span class="line">│   ├── include/</span><br><span class="line">│   │   └── mainwindow.h</span><br><span class="line">│   ├── qt_libs/         # Qt运行时库</span><br><span class="line">│   ├── run.sh           # 一体化部署脚本</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">├── env/                 # 开发环境</span><br><span class="line">│   ├── toolchain-arm.cmake # ARM工具链配置</span><br><span class="line">│   ├── FriendlyARM/     # ARM交叉编译工具</span><br><span class="line">│   └── QT4.7.0/         # Qt开发环境</span><br><span class="line">├── docker-compose.yml   # Docker Compose配置文件</span><br><span class="line">├── Dockerfile           # Docker镜像构建定义</span><br><span class="line">└── start.sh             # 交互式编译启动脚本</span><br></pre></td></tr></table></figure><h3 id="硬件要求">硬件要求</h3><ul><li><strong>开发板</strong>: ARM Cortex-A8 (如FriendlyARM Tiny210)</li><li><strong>GPIO</strong>: GPE0和GPE1端口</li><li><strong>LED</strong>: 8个LED灯连接到相应GPIO引脚</li><li><strong>存储</strong>: 最少64MB RAM，8MB Flash</li><li><strong>OS</strong>: Linux内核支持</li></ul><h3 id="开发环境">开发环境</h3><h4 id="编译工具链">编译工具链</h4><ul><li><strong>交叉编译器</strong>: ARM-Linux GCC/G++ 4.5.1<ul><li>用于在x86主机上编译ARM目标平台代码</li><li>支持C和C++语言开发</li><li>编译后的程序可在FriendlyARM开发板上运行</li></ul></li></ul><h4 id="开发框架">开发框架</h4><ul><li><strong>Qt 4.7.0</strong><ul><li>跨平台的C++图形用户界面应用程序开发框架</li><li>已针对ARM平台交叉编译</li><li>提供强大的GUI组件库和事件处理机制</li><li>本项目使用了QtCore和QtGui核心模块</li></ul></li></ul><h4 id="构建系统">构建系统</h4><ul><li><strong>CMake</strong><ul><li>通过toolchain-arm.cmake配置实现跨平台交叉编译</li><li>自动化构建流程，简化依赖管理</li><li>支持构建脚本自定义(build_arm.sh)</li></ul></li></ul><h3 id="安装指南">安装指南</h3><p>env.zip的环境包下载地址 <ahref="https://aistudio.baidu.com/datasetdetail/342360">长江大学课设环境_飞桨AIStudio星河社区</a></p><p>下载完解压放进根目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压环境包</span></span><br><span class="line">unzip env.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予env文件夹里面的所有可执行程序权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R +x <span class="built_in">env</span></span><br></pre></td></tr></table></figure><h4 id="使用docker构建项目">1、使用Docker构建项目</h4><ol type="1"><li><p><strong>克隆项目</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;项目仓库地址&gt;</span><br><span class="line"><span class="built_in">cd</span> 项目目录</span><br></pre></td></tr></table></figure></li><li><p><strong>运行Docker容器</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li><li><p><strong>进入容器交互环境</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it dev bash</span><br></pre></td></tr></table></figure></li><li><p><strong>在容器内使用start.sh脚本编译项目</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./start.sh</span><br></pre></td></tr></table></figure></li></ol><h4 id="非docker构建项目">2、 非Docker构建项目</h4><p><strong>Ubuntu24.04系统:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新包管理器</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装CMake</span></span><br><span class="line"><span class="built_in">sudo</span> apt install cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装32位库支持</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install libc6:i386 libstdc++6:i386 zlib1g:i386</span><br><span class="line"></span><br><span class="line"><span class="comment"># (可选) 使用国内镜像源加速</span></span><br><span class="line">bash &lt;(curl -sSL https://linuxmirrors.cn/main.sh)</span><br></pre></td></tr></table></figure><p><strong>Arch Linux系统:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新系统</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Syu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装CMake</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装32位库支持</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S --needed lib32-glibc lib32-zlib lib32-gcc-libs</span><br></pre></td></tr></table></figure><p><strong>逆序流水灯项目:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 逆序流水灯</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x ./build_arm.sh</span><br><span class="line"></span><br><span class="line">./build_arm.sh</span><br></pre></td></tr></table></figure><p><strong>数据库项目:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 数据库</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x ./build_arm.sh</span><br><span class="line"></span><br><span class="line">./build_arm.sh</span><br></pre></td></tr></table></figure><p><strong>Qt GUI项目:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> QT</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x ./run.sh</span><br><span class="line"></span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure><h3 id="使用方法开发板上">使用方法（开发板上）</h3><h4 id="逆序流水灯-1">逆序流水灯</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给予权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x led</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在开发板上直接运行</span></span><br><span class="line">./led</span><br></pre></td></tr></table></figure><p>程序将显示LED1-8的逆序流水效果，每个LED亮1秒。</p><h4 id="数据库演示">数据库演示</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给予权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x led</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在开发板上直接运行</span></span><br><span class="line">./sql_demo</span><br></pre></td></tr></table></figure><h4 id="qt-gui控制">Qt GUI控制</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压部署包</span></span><br><span class="line">tar -xzf led_package.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入打包的目录</span></span><br><span class="line"><span class="built_in">cd</span> led_package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给予权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x start.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接运行</span></span><br><span class="line">sh start.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 课设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 课设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内免费获取 DeepSeek API 服务及本地应用部署指南</title>
      <link href="/2025/02/24/%E6%95%99%E7%A8%8B/%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9%E8%8E%B7%E5%8F%96%20DeepSeek%20API%20%E6%9C%8D%E5%8A%A1%E5%8F%8A%E6%9C%AC%E5%9C%B0%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/"/>
      <url>/2025/02/24/%E6%95%99%E7%A8%8B/%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9%E8%8E%B7%E5%8F%96%20DeepSeek%20API%20%E6%9C%8D%E5%8A%A1%E5%8F%8A%E6%9C%AC%E5%9C%B0%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="国内免费获取-deepseek-api-服务及本地应用部署指南">国内免费获取DeepSeek API 服务及本地应用部署指南</h1><p>我们已成功部署NextChat服务，基于Groq的高性能70B大规模模型蒸馏技术，现已推出专业的网页对话端。如需体验更为高速与高效的deepseek-R170B大模型服务，欢迎访问<ahref="https://ai.crosery.cn/">Crosery</a>。</p><h2 id="一利用-groq-白嫖免费高速的-deepseek-70b-蒸馏模型">一、利用 Groq白嫖免费高速的 DeepSeek 70B 蒸馏模型</h2><h3 id="前提条件">前提条件</h3><ol type="1"><li>一个可用的 <a href="https://groq.com/">Groq</a>账号（需要注册）</li><li>一个本地的 AI 客户端 <a href="https://cherry-ai.com/">CherryStudio</a></li><li>科学上网工具 <a href="https://clashcn.com/clash-verge">ClashVerge</a></li></ol><h3 id="注册-groq-账号并申请-api">注册 Groq 账号并申请 API</h3><ol type="1"><li>访问 <a href="https://console.groq.com/login">Groq 官网</a></li><li>点击 <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241553056.png" />进行用 github 登录</li><li>在控制台获取 API 密钥，如图所示： <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241554215.png" /></li></ol><h3 id="api-调用方案">API 调用方案</h3><h4id="方案一下载-cherry-studio-的-ai-客户端进行本地对话易">方案一：下载Cherry Studio 的 AI 客户端进行本地对话（易）</h4><ol type="1"><li>访问 <a href="https://cherry-ai.com/">Cherry Studio</a>官网下载对应的软件</li><li>打开客户端页面点击左下角的小齿轮 <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241600629.png" />进行设置</li><li>选择 <strong>Groq 服务</strong> ，输入 <strong>API 密钥</strong>，然后添加 <strong>deepseek-r1-distill-llama-70b</strong> ，如图所示：<imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241602813.png" /></li><li>选择刚刚创建的 Groq 服务的模型，如图所示： <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241603434.png" /></li><li>然后即可开始对话，对话的时候要科学上网，如图所示： <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241604242.png" /></li><li>免科学上网的方案调用 API 的方案可以参考 <ahref="https://github.com/Ikaros-521/groq-proxy">Ikaros-521/groq-proxy:https://groq.com/ API 代理，借助 Deno 的能力，实现国内直连</a></li></ol><h4 id="方案二python-调用对应的-groq-服务易">方案二：Python 调用对应的Groq 服务（易）</h4><p><strong>更详细文档请参考官方</strong> <ahref="https://console.groq.com/docs/quickstart">Groq Cloud</a></p><ol type="1"><li>安装 Groq Python 库： <code>pip install groq</code></li><li>调用 API 服务：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> groq <span class="keyword">import</span> Groq</span><br><span class="line"></span><br><span class="line">client = Groq(</span><br><span class="line">    api_key=<span class="string">&quot;请输入你的 APIkey&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chat_completion = client.chat.completions.create(</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: <span class="string">&quot;解释快速语言模型的重要性&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    model=<span class="string">&quot;deepseek-r1-distill-llama-70b&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chat_completion.choices[<span class="number">0</span>].message.content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>运行结果如图所示： <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241613563.png" /></li></ol><h3 id="免费额度说明">免费额度说明</h3><p>免费额度信息如图所示： <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241615038.png" /></p><h4 id="方案三利用-nextchat-搭建网页对话端难">方案三：利用 NextChat搭建网页对话端（难）</h4><ol type="1"><li>进入 <ahref="https://github.com/ChatGPTNextWeb/NextChat">NextChat</a> 项目</li><li>点击官网的这个 <img src="https://vercel.com/button" alt="image" />按钮进行部署</li><li>进入之后点击 Create 进行创建对应的 Vercel 项目</li><li>点击项目的 settings -&gt; Environment Variables，具体设置如下： <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241634960.png" /></li><li>然后点击 Deployments 进行重新部署，如图所示： <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241635284.png" /></li><li>Vercel 绑定自己的域名，具体可参考 <ahref="https://blog.tangly1024.com/article/vercel-domain">Vercel应用如何绑定自己的域名 | Tangly 的学习笔记</a></li><li>利用域名解析使用国内加速节点，具体可参考右边博客 <ahref="https://www.yt-blog.top/9952/">推一下 Vercel 加速节点 -Fgaoxing_Fgaoxing 的个人博客</a></li><li>成功后就能看到自己项目成功部署的国内可以快速访问的页面了，如图所示：<imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241636240.png" /></li></ol><h2 id="二硅基流动免费白嫖-deepseek-r1-满血-api">二、硅基流动免费白嫖DeepSeek R1 满血 API</h2><h3 id="快速开始">快速开始</h3><ol type="1"><li>注册硅基流动的账号 <ahref="https://cloud.siliconflow.cn/i/8PWvzj0r">硅基流动</a>，官网有邀请活动，被邀和邀请者都有2000W token 的免费额度，如图所示： <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241646853.png" /></li><li>点击 API 密钥 -&gt; 新建 API 密钥 即可创建自己的 API密钥，如图所示： <imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202502241649116.png" /></li><li>调用API服务的详细请参考官方文档 <ahref="https://docs.siliconflow.cn/cn/userguide/quickstart">快速上手 -SiliconFlow</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> deepseek </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>galgame第一次汉化记录</title>
      <link href="/2025/01/31/galgame%E6%B1%89%E5%8C%96/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B1%89%E5%8C%96%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/01/31/galgame%E6%B1%89%E5%8C%96/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B1%89%E5%8C%96%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="游戏概述">游戏概述</h2><ul><li>游戏名称：しょうよん！ ～コドモ★ちゃれんじ～（柚子社早期作品）</li><li>原始语言：日文</li><li>目标语言：中文</li></ul><h2 id="汉化工具">汉化工具</h2><ul><li>使用的翻译：deepseeek-v3</li><li>使用的编辑器：vscode、IDA</li><li>其他辅助工具：winhex、吾爱破解(LCG)、GARbro、EXtractDATA</li></ul><h2 id="汉化过程">汉化过程</h2><h3 id="一分析游戏exe文件">一、分析游戏exe文件</h3><h4 id="更改游戏编码">① 更改游戏编码</h4><p>一般日本galgame的游戏编码都是shift-jis、近些年来少部分galgame的游戏编码是utf-8可以支持中文。所以想要完成游戏汉化，首先得把游戏里面的编码更改为支持中文的<strong>gbk</strong>编码</p><p>关于编码的一些经验之谈可以参考b站大佬的视频：[<ahref="https://www.bilibili.com/video/BV1fy4y157im/?spm_id_from=333.1387.upload.video_card.click">Gal汉化入门]#3.1编码&amp;范围校验修改演示_哔哩哔哩_bilibili</a></p><p>对于しょうよん！～コドモ★ちゃれんじ～这个游戏的游戏编码更改具体步骤如下：</p><p>1、通过利用<strong>吾爱破解(LCG)</strong>分析了游戏exe文件、在<strong>CreateFontA</strong>的输入函数下切换断点。</p><p>2、会发现编码的控制非常简单，只需将对应部分的0x80（shift-jis）-&gt;0x86（gbk）即可</p><figure><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202501311749187.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>3、更改完会发现游戏出现乱码，是因为原来的文本内容是shift-jis</p><p>可以通过这个断点将所有涉及到日文编码的部分全部更改为gbk编码，也就是将0x80更改为0x86既可，</p><figure><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202501311753114.png"alt="image-20250131175335926" /><figcaption aria-hidden="true">image-20250131175335926</figcaption></figure><h4 id="提取游戏脚本文件">② 提取游戏脚本文件</h4><p><strong>方法一：通过已有工具去提取脚本文本</strong></p><p>通过<strong>GARbro</strong>初步分析游戏里面的文件，发现arc.nsa相关的文件都是关于游戏里面的音频以及对应的图片和cg部分。一般的脚本文件的大小都不会太大，通过分析发现游戏的脚本文件为根目录的<strong>nscript.dat</strong>文件。这个文件利用<strong>ExtractData</strong>既可提取里面的内容，并且利用<strong>vscode</strong>进行打开</p><figure><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202501311828186.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>方法二：利用IDA进行逆向exe文件，分析里面的加密逻辑进行提取</strong></p><p>通过IDA进行逆向对应的exe文件，通过分析发现nscript.dat的读取解密逻辑在sub_40B390里面。发现里面对于nscript.dat文件的解密只是简单的与0x84进行异或既可</p><figure><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202501311833567.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>所以根据以上的分析可以很简单的得到对应的解密代码，下面是简单的用python进行实现的解密代码逻辑。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;nscript.dat&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    encrypted_data = f.read()</span><br><span class="line">decrypted_data = <span class="built_in">bytes</span>([b ^ <span class="number">0x84</span> <span class="keyword">for</span> b <span class="keyword">in</span> encrypted_data])</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;nscript_decrypted.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(decrypted_data)</span><br></pre></td></tr></table></figure><p>解密之后可以既可以得到里面的明文数据。</p><h4 id="文本汉化和应用">③ 文本汉化和应用</h4><p>通过搜索游戏里面开始出现的游戏文本<code>歩くだけで汗が流れ出る炎天下の中</code>，可以发现<strong>大概游戏文本出现在2508行</strong>的部分，前面也有相关控制游戏标题以及各种部分的日文，</p><p>其实也可以利用最简单的提取思路，<strong>只需要提取里面非英文以及英文标点符号之外的所有文本</strong>既可</p><p>利用re正则表达式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_jp_text</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="comment"># 正则表达式匹配非英文字符和标点</span></span><br><span class="line">    pattern = <span class="string">r&#x27;[^\u0020-\u007E]+&#x27;</span></span><br><span class="line">    <span class="comment"># 提取匹配的文本</span></span><br><span class="line">    jp_text = re.findall(pattern, text)</span><br><span class="line">    <span class="comment"># 无匹配文本则返回为None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> jp_text:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    jp_text = <span class="string">&quot;&quot;</span>.join(jp_text)</span><br><span class="line">    <span class="comment"># 过滤空白行</span></span><br><span class="line">    jp_text = jp_text.strip()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> jp_text</span><br></pre></td></tr></table></figure><p>可以利用AI大模型的接口去进行汉化，我这边推荐用<ahref="https://www.deepseek.com/">DeepSeek | 深度求索</a></p><p>对于如何应用进游戏有两个策略。</p><p>1、免封包策略</p><ul><li>优点：简单、可以不依赖逆向完成简单的应用</li><li>缺点：有时候会导致有大量的敏感明文翻译内容，很多平台无法上传自己的补丁</li></ul><p>2、加密封包策略</p><ul><li>优点：可以防止自己翻译的敏感明文内容被暴露</li><li>缺点：需要利用IDA等工具去进行分析exe里面的加密封包逻辑</li></ul><p><strong>方案一、免封包策略</strong></p><p>通过前面提取游戏脚本文件的分析我们可以很容易发现，文件一开始是读取了多个文件的操作，里面包括就有0.txt以及00.txt，如果没有读取到就解包nscript.dat</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !_access(<span class="string">&quot;0.txt&quot;</span>, <span class="number">0</span>) || !_access(<span class="string">&quot;00.txt&quot;</span>, <span class="number">0</span>) || _access(<span class="string">&quot;nscript.zat&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( _access(<span class="string">&quot;0.txt&quot;</span>, <span class="number">0</span>) &amp;&amp; _access(<span class="string">&quot;00.txt&quot;</span>, <span class="number">0</span>) &amp;&amp; !_access(<span class="string">&quot;nscript.dat&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = _open(<span class="string">&quot;nscript.dat&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    v10 = v9;</span><br><span class="line">    <span class="keyword">if</span> ( v9 == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v11 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v12 = _filelength(v9);</span><br><span class="line">      _close(v10);</span><br><span class="line">      v11 = v12;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(v11 + <span class="number">5</span>);</span><br><span class="line">    dword_<span class="number">5E0288</span> = (<span class="type">int</span>)v5;</span><br><span class="line">    *v5 = <span class="number">0</span>;</span><br><span class="line">    v13 = <span class="built_in">fopen</span>(<span class="string">&quot;nscript.dat&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    v7 = v13;</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="built_in">fgetc</span>(v13); i != <span class="number">-1</span>; i = <span class="built_in">fgetc</span>(v7) )</span><br><span class="line">      v5[v0++] = i ^ <span class="number">0x84</span>; <span class="comment">// 解密部分</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所以我们可以直接把利用<strong>ExtractData</strong>提取到的文本<strong>更改为00.txt或者0.txt</strong>放进游戏根目录然后将编码更改为前面我们已经修改为的GBK编码，再通过修改里面的剧情文本内容。最后发现游戏可以正常进入，并且测试正常</p><figure><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202501311921394.png"alt="image-20250131192140929" /><figcaption aria-hidden="true">image-20250131192140929</figcaption></figure><p><strong>方案二、加密封包策略</strong></p><p>通过前面利用IDA的分析，我们发现游戏的加密逻辑十分简单，故可以利用对应的python代码进行反向封包成dat文件，具体代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;128.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text_data = f.read()</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将文本转换为字节并加密</span></span><br><span class="line">binary_data = text_data.encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">encrypted_data = <span class="built_in">bytes</span>([b ^ <span class="number">0x84</span> <span class="keyword">for</span> b <span class="keyword">in</span> binary_data])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入dat文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;nscript1.dat&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(encrypted_data)</span><br></pre></td></tr></table></figure><p>将最后得到的dat文件放入游戏里面发现测试正常</p><figure><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202501311925591.png"alt="image-20250131192509318" /><figcaption aria-hidden="true">image-20250131192509318</figcaption></figure><h2 id="汉化总结">汉化总结</h2><p>经过不断的摸索，我的首个汉化补丁终于在2DFan上线啦！（<ahref="https://2dfan.com/downloads/32922">补丁下载地址</a>）作为汉化新手，这次从翻译到技术调试全程自学的经历，让我真正体会到汉化工作的不易——每一个流畅运行的补丁背后，都是无数细节的打磨和付出的努力。</p><p><strong>关于这次汉化：</strong>虽然是第一次尝试，但过程中积累了许多实用经验：比如游戏文本的提取以及相关工具的使用。特别推荐B站UP主<strong>Dir-A</strong>的教程（<ahref="https://space.bilibili.com/8144708">主页链接</a>），他的GitHub技术文档（<ahref="https://github.com/Dir-A/Dir-A_Essays_MD">Dir-A_Essays_MD</a>）给了我超多帮助！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 汉化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> galgame汉化 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS双线巡线方案</title>
      <link href="/2024/07/31/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/ROS%E5%8F%8C%E7%BA%BF%E5%B7%A1%E7%BA%BF%E6%96%B9%E6%A1%88/"/>
      <url>/2024/07/31/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/ROS%E5%8F%8C%E7%BA%BF%E5%B7%A1%E7%BA%BF%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="ros双线巡线方案----第十九届科大讯飞智能车比赛">🚗ROS双线巡线方案 -- 第十九届科大讯飞智能车比赛</h1><p>这个ROS包是由<strong>长江大学极客班</strong>的极客👨‍💻👩‍💻开源，是第19届科大讯飞智能车救援组巡线比赛定制的方案，也可以用于其他双线内巡线的参考的ROS包方案。</p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/demo.gif" /></p><h2 id="一起开源推动科技进步">🌟 一起开源，推动科技进步</h2><p>在这个快速变化的时代，开源是推动技术进步和创新的关键力量。通过分享我们的知识和代码，我们不仅可以加速技术的发展，还能培养新一代的工程师和开发者。我们鼓励大家加入开源社区，分享你的创意和成果，让更多人受益。</p><p>无论你是一个初学者还是经验丰富的专家，都可以在开源项目中找到你的位置。每一行代码、每一个建议都能为项目注入新的活力。让我们携手合作，共同推动科技的进步，创造一个更加开放和互联的世界。</p><p><strong>开源地址</strong>：</p><ul><li>Gitee：<ahref="https://gitee.com/changjiang-university_2/Line_Follower">Gitee</a></li><li>Github：<ahref="https://github.com/Crosery/ROS_Line_Follower">Github</a></li></ul><h2 id="闪亮特性">🌟 闪亮特性</h2><ul><li>🧠 智能图像处理：就像给你的小车装了一双火眼金睛</li><li>🎛️ 灵活PID控制：平滑巡线，宛如小车在跳华尔兹</li><li>🔧 超强可配置性：可以自由的调教你的小车</li></ul><h2 id="你需要准备的工具箱">🛠️ 你需要准备的工具箱</h2><p>在开始之前，请确保你的系统已经安装了以下环境和依赖：</p><ul><li>ROS（我们在Noetic上反复蹂躏测试过）</li><li>OpenCV（没有它，你的小车就像失明了一样）</li><li>其他一些厉害的库：cv_bridge、image_transport、sensor_msgs、geometry_msgs</li><li>Markdown环境（用于查看和编辑本README文件）</li></ul><blockquote><p>💡 提示：如果你还没有安装Markdown环境，可以使用VSCode或Typora等编辑器，它们对Markdown有很好的支持。</p></blockquote><h2 id="包的内部构造">📁 包的内部构造</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">line_follower/</span><br><span class="line">├── src/</span><br><span class="line">│   └── line_follower_node.cpp  (核心代码，小车的大脑！)</span><br><span class="line">├── config/</span><br><span class="line">│   ├── image.cfg  (调教你的火眼金睛)</span><br><span class="line">│   └── pid.cfg   (调教你的平衡感)</span><br><span class="line">├── launch/</span><br><span class="line">│   └── line_follower.launch  (一键启动，像魔法一样简单)</span><br><span class="line">├── rviz/</span><br><span class="line">│   └── img_follow_rviz_config.rviz  (RViz配置文件，可视化小车的路径跟踪)</span><br><span class="line">├── include/</span><br><span class="line">│   └── line_follower/  (头文件，用于代码的模块化和重用)</span><br><span class="line">├── CMakeLists.txt  (CMake配置文件，定义了如何构建项目)</span><br><span class="line">└── package.xml  (包配置文件，定义了包的元数据，如依赖关系、版本等)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何调教你的小车">⚙️ 如何调教你的小车</h2><ol type="1"><li><p>找个安静的地方，克隆这个包：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/catkin_ws/src</span><br><span class="line">git clone https://gitee.com/changjiang-university_2/Line_Follower.git</span><br></pre></td></tr></table></figure></li><li><p>给它点营养，编译一下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure></li><li><p>在Ubuntu中安装C++ OpenCV依赖：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install libopencv-dev</span><br></pre></td></tr></table></figure></li><li><p>告诉它该干活了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure></li><li><p>打开小车的眼睛</p><p>需要启动你小车的摄像头，并且订阅对应的话题，在<code>config/pid.cfg</code>里面修改对应的话题名称</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">image_topic=/new_camera/image # 更改图像话题名称以匹配新设备</span><br></pre></td></tr></table></figure></li><li><p>启动动力能源</p><p>需要启动你小车的底盘，让小车能够进行运动，比如科大讯飞的ucar-mini一代车启动实例如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roslaunch ucar_controller base_driver.launch</span><br></pre></td></tr></table></figure></li><li><p>唤醒你的小车：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roslaunch line_follower line_follower.launch</span><br></pre></td></tr></table></figure></li></ol><h2 id="核心代码解密">🧠 核心代码解密</h2><p>我们的核心代码藏在 <code>src/line_follower_node.cpp</code>里面。来看看它有什么秘密：</p><ol type="1"><li><code>ImageProcessor</code> 类：这是小车的眼睛🧐</li></ol><ul><li>它能在杂乱的画面中精准找到那条线，就像在人海中一眼认出自己的对象✨</li></ul><ol start="2" type="1"><li><code>LineFollower</code> 类：这是小车的大脑和肌肉💪</li></ol><ul><li>它决定小车该怎么走，左转还是右转，快跑还是慢走🚗</li></ul><ol start="3" type="1"><li>参数读取：我们让小车变得很听话，你说什么它就怎么做👂</li><li>PID控制：这就像是给小车装了一个平衡器，让它走起路来虎虎生风🏋️‍♂️</li><li>调试输出：让你随时了解小车在想什么，做什么💡</li><li>图像话题：订阅<code>/img_follow</code>，就像打开小车眼睛的滤镜，一窥<code>ImageProcessor</code>如何把混乱变清晰，小车视角的独家揭秘，就在这里！👀</li></ol><h3 id="pid调参详解">🎛️ PID调参详解</h3><p>PID控制是这个包的核心功能之一。在 <code>config/pid.cfg</code>文件中，你可以找到以下关键参数：</p><ul><li><code>Kp</code>：比例系数，控制转向的快速响应</li><li><code>Ki</code>：积分系数，用于消除稳态误差</li><li><code>Kd</code>：微分系数，用于抑制振荡</li></ul><p>调参小贴士：</p><ul><li>先调 <code>Kp</code>：增大 <code>Kp</code>直到系统开始震荡，然后减小到震荡消失</li><li>再调 <code>Kd</code>：增大 <code>Kd</code>以减小过冲，但不要太大以免引入高频噪声</li><li>最后调 <code>Ki</code>：缓慢增加 <code>Ki</code>以消除稳态误差，但要注意不要引起振荡</li></ul><p>此外，我们的PID控制系统不仅仅是一个简单的PID控制器，它包含了多个高级特性，使得小车能够更好地适应各种赛道条件。以下是对这些特性的详细介绍：</p><p>以下是一个完整的PID配置实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">巡线机器人PID配置文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基本参数</span></span><br><span class="line">max_linear_speed=0.25   # 最大线速度 (m/s)</span><br><span class="line">max_angular_speed=1.0   # 最大角速度 (rad/s)</span><br><span class="line">Kp=0.005                # 比例增益</span><br><span class="line">Ki=0.000005             # 积分增益</span><br><span class="line">Kd=0.009                # 微分增益</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">高级参数</span></span><br><span class="line">deadzone=30             # 死区 (像素)</span><br><span class="line">integral_limit=0.06     # 积分限幅，防止积分饱和</span><br><span class="line">error_threshold=60      # 积分分离阈值，大误差时停止积分</span><br><span class="line">soft_limit_lower=-1.0   # 软限幅下限</span><br><span class="line">soft_limit_upper=1.0    # 软限幅上限</span><br><span class="line">filter_coefficient=0.7  # 输入滤波系数，用于平滑输入信号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他参数</span></span><br><span class="line">pid_debug_output=false  # 控制是否打印调试信息</span><br><span class="line">end_audio_msg=/home/ucar/Desktop/ucar/src/main/navacation/voice_packge/任务完成/任务完成.wav # 结束之后播报的音频</span><br></pre></td></tr></table></figure><p>此外，我们的PID控制系统不仅仅是一个简单的PID控制器，它包含了多个高级特性，使得小车能够更好地适应各种赛道条件。以下是对这些特性的详细介绍：</p><h3 id="输入滤波">1. 输入滤波</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> filteredError = filter_coefficient_ * error + (<span class="number">1</span> - filter_coefficient_) * lastFilteredError;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：减少传感器噪声对控制系统的影响，使控制更加平滑。</p><p><strong>参数调整</strong>：</p><ul><li><code>filter_coefficient</code>：范围从0到1。值越大，滤波效果越弱；值越小，滤波效果越强。</li><li>建议从0.7开始，根据小车的反应进行微调。</li></ul><h3 id="死区控制">2. 死区控制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(filteredError) &lt; deadzone_)</span><br><span class="line">&#123;</span><br><span class="line">    filteredError = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    filteredError = (filteredError &gt; <span class="number">0</span>) ? filteredError - deadzone_ : filteredError + deadzone_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：防止小误差引起的频繁抖动，提高系统稳定性。</p><p><strong>参数调整</strong>：</p><ul><li><code>deadzone</code>：根据你的赛道宽度和摄像头分辨率来设定。</li><li>从误差值的1-2%开始，逐步增加直到小车在直线上能保持稳定。</li></ul><h3 id="自适应pid参数">3. 自适应PID参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">adaptPIDParameters</span><span class="params">(<span class="type">double</span> error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(error) &gt; error_threshold_ * <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        adaptive_Kp_ = Kp_ * <span class="number">1.5</span>;</span><br><span class="line">        adaptive_Ki_ = Ki_ * <span class="number">0.5</span>;</span><br><span class="line">        adaptive_Kd_ = Kd_ * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        adaptive_Kp_ = Kp_;</span><br><span class="line">        adaptive_Ki_ = Ki_;</span><br><span class="line">        adaptive_Kd_ = Kd_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：根据误差大小动态调整PID参数，使得小车在不同情况下都能有最佳表现。</p><p><strong>参数调整</strong>：</p><ul><li><code>error_threshold</code>：决定何时启用自适应参数。建议设置为正常误差范围的2倍左右。</li><li>调整系数（如1.5，0.5，2）：根据小车在大弯道和直道上的表现来调整。</li></ul><h3 id="积分分离">4. 积分分离</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(filteredError) &lt; error_threshold_)</span><br><span class="line">&#123;</span><br><span class="line">    integral += filteredError;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    integral = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：防止积分饱和，减少大幅度转向时的过冲现象。</p><p><strong>参数调整</strong>：</p><ul><li><code>error_threshold</code>：与自适应PID中的阈值可以保持一致。</li></ul><h3 id="积分限幅">5. 积分限幅</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">integral = <span class="built_in">max</span>(-integral_limit_, <span class="built_in">min</span>(integral_limit_, integral));</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：进一步防止积分饱和，提高系统稳定性。</p><p><strong>参数调整</strong>：</p><ul><li><code>integral_limit_</code>：开始时可以设置为最大允许转向角的10-20%，然后根据小车表现进行调整。</li></ul><h3 id="微分先行">6. 微分先行</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> derivative = filteredError - lastError;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：提高系统响应速度，减少超调。</p><p><strong>参数调整</strong>：</p><ul><li>主要通过调整 <code>Kd_</code> 来控制微分作用的强度。</li></ul><h3 id="软限幅">7. 软限幅</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">steeringAngle = <span class="built_in">max</span>(soft_limit_lower_, <span class="built_in">min</span>(soft_limit_upper_, steeringAngle));</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：防止输出饱和，使转向更加平滑。</p><p><strong>参数调整</strong>：</p><ul><li><code>soft_limit_lower</code> 和<code>soft_limit_upper</code>：根据你的舵机或电机的实际转向范围来设定。</li></ul><h3 id="参数调整总体建议">参数调整总体建议</h3><ol type="1"><li>从基础PID参数（<code>Kp_</code>, <code>Ki_</code>,<code>Kd_</code>）开始调整，使小车能基本循线。</li><li>逐步引入高级特性，每次只调整一个参数，观察小车表现。</li><li>使用调试输出(<code>pid_debug_output_</code>)来监控误差和输出值，帮助你更好地理解参数变化对系统的影响。</li><li>在不同类型的赛道上反复测试，找到一个能适应大多数情况的参数组合。</li><li>记录每次调整的结果，这将帮助你更快地找到最佳参数。</li></ol><h2 id="图像处理局限性">🖼️ 图像处理局限性</h2><p>请注意，当前的图像处理算法主要针对<strong>白线和蓝底的巡线方案</strong>进行了优化。如果你的赛道条件不同，可能需要修改<code>ImageProcessor</code> 类中的 <code>processImage</code> 函数。</p><p>特别是，你可能需要调整 <code>config/pid.cfg</code>以下部分：</p><ul><li><strong>颜色阈值</strong>：调整 <code>line_threshold</code>值。这个部分较为死板，推荐使用 HSV 图像进行优化，然后自己添加参数。</li><li><strong>图像分割方法</strong>：如果你的赛道有不同的颜色或纹理，可能需要使用更复杂的图像分割算法。</li></ul><h3 id="配置示例">配置示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">line_threshold=220            # 提高阈值以检测更亮的线</span><br><span class="line">range_y=4                     # 增加垂直分割比例以检测更大的图像区域</span><br><span class="line">center_p=3                    # 扩展中心线参数以适应更宽的线条</span><br><span class="line">boundary_check_width=2        # 增加边界检测宽度以增强边界识别</span><br><span class="line">img_debug_output=false        # 禁用图像调试信息以提高性能</span><br><span class="line">image_topic=/new_camera/image # 更改图像话题名称以匹配新设备</span><br><span class="line">end_dist=7                    # 增加停止阈值以适应更长的赛道</span><br></pre></td></tr></table></figure><h3 id="适应其他场景的建议">适应其他场景的建议</h3><ul><li><strong>调整颜色阈值</strong>：根据赛道的实际颜色情况调整<code>line_threshold</code> 值，使用 HSV色彩空间可以更灵活地处理不同的颜色。</li><li><strong>改进图像分割</strong>：尝试使用不同的图像分割技术，如区域生长、边缘检测或深度学习方法，以适应不同的赛道条件。</li><li><strong>增强边界检测</strong>：调整<code>boundary_check_width</code>以增强边界检测的鲁棒性，特别是在复杂背景下。</li></ul><p>我们鼓励你发挥创意，尝试不同的图像处理技术，以适应你的特定应用场景。</p><h2 id="许可证">📜 许可证</h2><p>我们采用MIT许可证，这意味着你可以随意使用、修改、分发这个项目，但请保留我们的版权信息哦！</p><h2 id="致谢">🙏 致谢</h2><ul><li>感谢科大讯飞智能车比赛给了我们这个大显身手的机会</li><li>感谢ROS和OpenCV社区，没有你们，我们的小车就是个瞎子</li><li>感谢所有为开源社区做出贡献的开发者们，你们的智慧和奉献让技术变得更加开放和共享。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 双线巡线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准C语言实现简单Web服务器</title>
      <link href="/2024/04/01/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E8%AE%BE/%E6%A0%87%E5%87%86C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/04/01/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E8%AE%BE/%E6%A0%87%E5%87%86C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="标准c语言实现简单web服务器">标准C语言实现简单Web服务器</h1><p>本课设任务来自<strong>长江大学</strong>计算机网络课设任务四！</p><p>环境需要：<strong>Visual Studio 2022</strong> +<strong>CMake</strong> + <strong>命令行编译</strong></p><h2 id="一项目介绍">一、项目介绍</h2><h3 id="任务要求">📋 任务要求</h3><p><strong>设计目标：</strong></p><p>完成基础的tcp连接，支持基础的client与其连接，简单的http访问，支持静态页面访问，需要一定的报错机制，如404页面的建立。</p><ol type="1"><li>socket实现简单Http服务器，完成html的解析；</li><li>运行该服务器可以通过浏览器访问服务器目录下的Html文件、jpg图片、css文件的载入。 完成初步的Http服务器功能。</li></ol><p><strong>相关技术：</strong></p><p>Server端:</p><ol type="1"><li>完成socket(),bind(),listen()这些初始化工作后，调用accept()方法阻塞等待，等待Client的connect()方法连接</li><li>处理HTTP请求，解析请求行、请求头，返回相应的静态文件或错误页面</li></ol><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202506130059864.png" /></p><h2 id="二运行截图">二、运行截图</h2><p><strong>代码实现效果</strong>：</p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202506130059259.png" /></p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202506130059444.png" /></p><h2 id="三开发环境安装">三、开发环境安装</h2><h3 id="visual-studio-2022-安装推荐">3.1 Visual Studio 2022安装（推荐）</h3><p><strong>下载地址</strong>：<ahref="https://visualstudio.microsoft.com/zh-hans/vs/">Visual Studio 2022Community</a></p><h3 id="cmake-安装">3.2 CMake 安装</h3><p><strong>下载地址</strong>：<ahref="https://cmake.org/download/">CMake官网</a></p><p><strong>安装步骤</strong>：</p><ol type="1"><li>下载CMake最新版本的Windows x64 Installer</li><li>运行安装程序</li><li><strong>重要</strong>：安装时勾选"Add CMake to the system PATH forall users"</li><li>完成安装后，打开命令行验证： <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure></li></ol><h3 id="git-安装可选">3.3 Git 安装（可选）</h3><p>用于克隆项目代码：</p><p><strong>下载地址</strong>：<ahref="https://git-scm.com/download/win">Git for Windows</a></p><h2 id="四项目结构">四、项目结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C_web/</span><br><span class="line">├── CMakeLists.txt                 # CMake构建配置文件</span><br><span class="line">├── README.md                      # 项目说明文档</span><br><span class="line">│</span><br><span class="line">├── include/                       # 头文件目录</span><br><span class="line">│</span><br><span class="line">├── src/                          # 源代码目录</span><br><span class="line">│   └── main.c                    # 主程序源文件</span><br><span class="line">│</span><br><span class="line">├── resources/                    # 资源文件目录</span><br><span class="line">│   ├── index.html               # 主页HTML文件</span><br><span class="line">│   ├── 404.html                 # 404错误页面</span><br><span class="line">│   ├── css/                     # CSS样式文件目录</span><br><span class="line">│   ├── js/                      # JavaScript文件目录</span><br><span class="line">│   ├── img/                     # 图片资源目录</span><br><span class="line">│   └── music/                   # 音乐资源目录</span><br><span class="line">│</span><br><span class="line">└── img/                         # 项目文档图片目录</span><br></pre></td></tr></table></figure><h2 id="五编译与运行">五、编译与运行</h2><h3 id="cmake-命令行">5.1 CMake + 命令行</h3><p><strong>步骤</strong>：</p><ol type="1"><li><p><strong>打开命令行</strong>：</p><ul><li>按 <code>Win + R</code>，输入 <code>cmd</code>，回车</li><li>或在项目文件夹按住 <code>Shift</code>右键，选择"在此处打开PowerShell窗口"</li></ul></li><li><p><strong>进入项目目录</strong>：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 项目工作目录</span><br></pre></td></tr></table></figure></li><li><p><strong>配置项目</strong>（首次运行）：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cmake -B build -S .</span><br></pre></td></tr></table></figure></li><li><p><strong>编译项目</strong>：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># Debug版本（默认）</span><br><span class="line">cmake --build build</span><br><span class="line"></span><br><span class="line"># Release版本（性能更好）</span><br><span class="line">cmake --build build --config Release</span><br></pre></td></tr></table></figure></li><li><p><strong>运行程序</strong>：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># Debug版本</span><br><span class="line">bin\Debug\main.exe</span><br><span class="line"></span><br><span class="line"># Release版本</span><br><span class="line">bin\Release\main.exe</span><br><span class="line"></span><br><span class="line"># 指定端口运行</span><br><span class="line">bin\Debug\main.exe <span class="number">9000</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="方式二gcc命令行编译">5.2 方式二：GCC命令行编译</h3><p><strong>前提</strong>：需要安装MinGW-w64或使用WSL</p><p><strong>教程：</strong><ahref="https://www.cnblogs.com/zijie1024/articles/18376803">环境搭建 |Windows中MinGW-w64及GCC的下载、安装与配置 - 字节幺零二四 -博客园</a></p><p><strong>编译命令</strong>：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 基础编译</span><br><span class="line">gcc -o webserver src/main.c -lws2_32</span><br><span class="line"></span><br><span class="line"># 带调试信息</span><br><span class="line">gcc -g -o webserver src/main.c -lws2_32</span><br><span class="line"></span><br><span class="line"># 优化编译</span><br><span class="line">gcc -O2 -o webserver src/main.c -lws2_32</span><br><span class="line"></span><br><span class="line"># 运行</span><br><span class="line">./webserver.exe</span><br></pre></td></tr></table></figure><h2 id="六快速开始">六、快速开始</h2><h3 id="第一次运行">6.1 第一次运行</h3><ol type="1"><li><p><strong>下载/克隆项目</strong>：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/Crosery/C_web.git</span><br><span class="line"><span class="built_in">cd</span> C_web</span><br></pre></td></tr></table></figure></li><li><p><strong>选择编译方式</strong>（推荐CMake）：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cmake -B build -S .</span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure></li><li><p><strong>将resources文件放进与main.exe的同级目录</strong>：</p><p><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi_picture/202506130059704.png" /></p></li><li><p><strong>运行服务器</strong>：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bin\Debug\main.exe</span><br></pre></td></tr></table></figure></li><li><p><strong>访问网站</strong>：</p><ul><li>打开浏览器</li><li>访问：<code>http://localhost:8007</code></li></ul></li></ol><h2 id="七配置文件">七、配置文件</h2><h3 id="环境配置文件.env">7.1 环境配置文件（.env）</h3><p>在项目根目录创建 <code>.env</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 服务器配置</span><br><span class="line">SERVER_PORT=8007</span><br><span class="line">SERVER_IP_ADDR=0.0.0.0</span><br><span class="line">BACKLOG=10</span><br><span class="line">BUF_SIZE=8192</span><br><span class="line">OK=1</span><br><span class="line">ERROR=0</span><br></pre></td></tr></table></figure><h3 id="cmakelists.txt-说明">7.2 CMakeLists.txt 说明</h3><p>项目已包含完整的CMake配置：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake最小版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可执行文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动收集src目录下的所有源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">    main</span><br><span class="line">    <span class="variable">$&#123;SRC_LIST&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="八自定义配置教程">八、自定义配置教程</h2><h3 id="修改端口配置">8.1 修改端口配置</h3><p><strong>方法一：环境配置文件</strong>（推荐）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SERVER_PORT=9999  # 修改为你的端口</span><br></pre></td></tr></table></figure><p><strong>方法二：命令行参数</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin\Debug\main.exe 9999</span><br></pre></td></tr></table></figure><p><strong>方法三：修改源码</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.c 中修改</span></span><br><span class="line"><span class="type">int</span> g_server_port = <span class="number">9999</span>;  <span class="comment">// 你的端口号</span></span><br></pre></td></tr></table></figure><h3 id="修改个人信息">8.2 修改个人信息</h3><p><strong>修改服务器作者信息</strong>：</p><p>编辑 <code>src/main.c</code>，找到 <code>display_server_logo()</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;                          Created by 你的姓名\n\n&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>修改网页个人信息</strong>：</p><p>编辑 <code>index.html</code>，找到个人信息部分：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Ciallo～(∠・ω&lt; )⌒☆&#x27;)&quot;</span>&gt;</span>计算机网络课设<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;subtitle-button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Ciallo～(∠・ω&lt; )⌒☆&#x27;)&quot;</span>&gt;</span>你的姓名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;additional-text&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;location.href = &#x27;nonexistent.html&#x27;;&quot;</span>&gt;</span>Ciallo～(∠・ω&lt; )⌒☆<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="九常见问题解决">九、常见问题解决</h2><h3 id="编译问题">9.1 编译问题</h3><p><strong>问题1：cmake不是内部或外部命令</strong></p><p>解决方案：</p><ol type="1"><li>重新安装CMake，确保勾选"Add to PATH"</li><li>重启命令行或重启电脑</li><li>手动添加CMake到环境变量PATH</li></ol><p><strong>问题2：找不到编译器</strong></p><p>解决方案：</p><ol type="1"><li>确保安装了Visual Studio 2022的C++工具</li><li>在开发者命令提示符中运行CMake：<ul><li>开始菜单搜索"Developer Command Prompt for VS 2022"</li></ul></li></ol><p><strong>问题3：链接错误 ws2_32.lib</strong></p><p>解决方案：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保代码中包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="运行问题">9.2 运行问题</h3><p><strong>问题1：端口被占用</strong></p><p>解决方案：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看端口占用</span></span><br><span class="line">netstat -ano | findstr :8007</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换端口</span></span><br><span class="line">bin\Debug\main.exe 9000</span><br></pre></td></tr></table></figure><p><strong>问题2：防火墙拦截</strong></p><p>解决方案：</p><ol type="1"><li>Windows Defender → 允许应用通过防火墙</li><li>添加main.exe到允许列表</li></ol><h2 id="十日志系统说明">十、日志系统说明</h2><h3 id="日志级别和颜色">10.1 日志级别和颜色</h3><table><thead><tr><th>级别</th><th>颜色</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td>LOG_INFO</td><td>🔵 蓝色</td><td>一般信息</td><td>服务器启动</td></tr><tr><td>LOG_SUCCESS</td><td>🟢 绿色</td><td>成功操作</td><td>文件发送成功</td></tr><tr><td>LOG_WARNING</td><td>🟡 黄色</td><td>警告信息</td><td>配置文件未找到</td></tr><tr><td>LOG_ERROR</td><td>🔴 红色</td><td>错误信息</td><td>文件不存在</td></tr><tr><td>LOG_DETAIL</td><td>🔷 青色</td><td>详细信息</td><td>请求详情</td></tr><tr><td>LOG_CONFIG</td><td>🟣 紫色</td><td>配置信息</td><td>端口配置</td></tr></tbody></table><h3 id="日志示例输出">10.2 日志示例输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ████████████████████████████████████████████████████████</span><br><span class="line">    █                                                      █</span><br><span class="line">    █    ██╗    ██╗███████╗██████╗     ███████╗██████╗     █</span><br><span class="line">    █    ██║    ██║██╔════╝██╔══██╗    ██╔════╝██╔══██╗    █</span><br><span class="line">    █    ██║ █╗ ██║█████╗  ██████╔╝    ███████╗██████╔╝    █</span><br><span class="line">    █    ██║███╗██║██╔══╝  ██╔══██╗    ╚════██║██╔══██╗    █</span><br><span class="line">    █    ╚███╔███╔╝███████╗██████╔╝    ███████║██║  ██║    █</span><br><span class="line">    █     ╚══╝╚══╝ ╚══════╝╚═════╝     ╚══════╝╚═╝  ╚═╝    █</span><br><span class="line">    █                                                      █</span><br><span class="line">    ████████████████████████████████████████████████████████</span><br><span class="line"></span><br><span class="line">                          Created by Crosery</span><br><span class="line"></span><br><span class="line">==================== 环境配置加载 ====================</span><br><span class="line">[信息] 正在加载环境变量配置...</span><br><span class="line">[配置] 服务器端口: 8007</span><br><span class="line">[配置] 服务器IP: 0.0.0.0</span><br><span class="line">[成功] 环境变量配置加载完成！</span><br><span class="line">======================================================</span><br><span class="line"></span><br><span class="line">==================== 套接字初始化 ====================</span><br><span class="line">[信息] 正在初始化服务器套接字...</span><br><span class="line">[成功] Winsock 库加载成功。</span><br><span class="line">[成功] 套接字创建成功。</span><br><span class="line">[成功] 套接字绑定成功，监听于 0.0.0.0:8007</span><br><span class="line">======================================================</span><br><span class="line"></span><br><span class="line">[信息] Web 服务器已启动，监听端口: 8007</span><br><span class="line">[信息] 当前工作目录: F:\Desktop\C_web</span><br><span class="line">[信息] 访问 http://localhost:8007 开始使用。</span><br><span class="line">==================== 服务器运行中 ====================</span><br></pre></td></tr></table></figure><h2 id="十一支持的文件类型">十一、支持的文件类型</h2><p>服务器支持以下文件类型的自动MIME类型识别：</p><table><thead><tr><th>文件类型</th><th>扩展名</th><th>MIME类型</th></tr></thead><tbody><tr><td>网页文件</td><td><code>.html</code></td><td><code>text/html</code></td></tr><tr><td>样式文件</td><td><code>.css</code></td><td><code>text/css</code></td></tr><tr><td>脚本文件</td><td><code>.js</code></td><td><code>application/javascript</code></td></tr><tr><td>图片文件</td><td><code>.jpg/.jpeg</code></td><td><code>image/jpeg</code></td></tr><tr><td>图片文件</td><td><code>.png</code></td><td><code>image/png</code></td></tr><tr><td>图片文件</td><td><code>.gif</code></td><td><code>image/gif</code></td></tr><tr><td>文本文件</td><td><code>.txt</code></td><td><code>text/plain</code></td></tr><tr><td>XML文件</td><td><code>.xml</code></td><td><code>text/xml</code></td></tr><tr><td>JSON文件</td><td><code>.json</code></td><td><code>application/json</code></td></tr><tr><td>音频文件</td><td><code>.mp3</code></td><td><code>audio/mpeg</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 课设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课设 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Q群机器人基本使用教程</title>
      <link href="/2023/09/30/ROBOT/Q%E7%BE%A4%E4%BA%91%E5%B4%BD%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2023/09/30/ROBOT/Q%E7%BE%A4%E4%BA%91%E5%B4%BD%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="q群机器人基本使用教程">Q群机器人基本使用教程</h1><p>这个教程就是针对于本人根据<strong>云崽框架</strong>搭建的QQ机器人的相关使用教程，教程如下</p><h2 id="一机器人基本介绍">一、机器人基本介绍</h2><p>机器人在Q群里面的名称叫做纳西妲（因为群主是纳西妲单推人），QQ号是1461277498，里面的很多功能在群聊也可以用，私聊一样可以。所以可以加机器人QQ，使用我用Chatgpt-plugin插件内置的gpt功能，也可以在群里面@机器人然后发你想询问的信息就可以。</p><p><strong>机器人内置插件如下图</strong>：</p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272302413.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272302413.png"alt="image-20230727230210188" /></a></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272302677.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272302677.png"alt="image-20230727230220582" /></a></p><p>很多的插件都有相应的功能，<strong>一般的插件都会有对应功能的帮助面板</strong>，当然里面也只有一些常用的插件。</p><h2 id="二插件帮助面板">二、插件帮助面板</h2><p>对机器人发送对应的像（#{name}帮助）的<strong>指令</strong>就可以唤起对应的帮助面板，比如我机器人默认的就是喵喵插件的帮助，就可以发送<code>#帮助</code>或者<code>#喵喵帮助</code>得到对应的功能面板，如下图展示</p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272305660.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272305660.png"alt="image-20230727230549577" /></a></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272305036.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272305036.png"alt="image-20230727230557952" /></a></p><p>这里面{name}就是填写对应插件的名字，然后发送成功后就可以得到对应的帮助面板，本群常用的有<strong>喵喵插件、星铁插件、土块插件、枫叶插件等等</strong>。如果你要唤起星铁插件的帮助面板就发<code>#星铁帮助</code>，如果你要土块插件的帮助面板就发<code>#土块帮助</code>其他的同理。还有就是本群很多的插件功能面板图都在群精华信息内。</p><h2id="三如何使用插件帮助面板图的功能">三、如何使用插件帮助面板图的功能</h2><p>以喵喵帮助面板的功能为例子</p><p>喵喵插件有很多栏的功能，我们先来看第三栏</p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272316673.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272316673.png"alt="image-20230727231608460" /></a></p><p>上面的这些功能只要按照上面的提示输入就可以让机器人回复对应功能得到的结果，比如第一个<code>#体力</code>，就只需要对机器人，或者在群聊哪里发出对应的指令即可，比如看以下的操作</p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272325460.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272325460.png"alt="image-20230727232506346" /></a></p><p>这个就是查询体力的服务，但是一般一开始没有这个功能，这个功能需要<strong>绑定cookie</strong>，这个的话在四再细说怎么绑定。帮助面板上面有很多功能都可以根据相关提示去使用，有兴趣的话可以都试着私聊机器人或者在群聊里面进行发送。</p><p>另外在介绍下ai绘图的帮助，ai绘图帮助的话是基于土块插件帮助的一个功能帮助，需要对机器人发送<code>#画图帮助</code>就可以得到对应的帮助面板</p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272328204.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272328204.png"alt="image-20230727232822135" /></a></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272328750.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272328750.png"alt="image-20230727232843609" /></a></p><p>可以看到上面有很多的功能，同样的以第一个功能来举例，我们如果要使用ai#绘图的话可以对机器人发送<code>#绘个图 &#123;对应的图片描述tag&#125;</code>，比如我想要画个泳装的纳西妲的话，里面的关键词是纳西妲，泳装。此时我就要对机器人发送<code>#绘个图 纳西妲，泳装</code>，得到的结果如下所示</p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272331438.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272331438.png"alt="image-20230727233120337" /></a></p><p>此时就得到了符合条件的ai作画！</p><h2id="四关于cookie以及token的绑定stoken也可以用于星铁cookie的绑定">四、关于cookie以及token的绑定（stoken也可以用于星铁cookie的绑定）</h2><h3id="方法一最简单很推荐但最好多设备扫码登录法">1、方法一（最简单，很推荐，但最好多设备）：#扫码登录法</h3><p>此方法需要在一台设备上面对机器人发送<code>#扫码登录</code>，然后用另外一台设备进入米游社去扫码，其实一个设备也行，不过你要保存机器人发送给你的二维码然后再去米游社扫码，操作如下</p><p><strong>1、对机器人发送#扫码登录</strong></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272336616.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272336616.png"alt="image-20230727233603554" /></a></p><p><strong>2、登录米游社进行扫码，尽量要快不然机器人会撤回！</strong></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272337098.jpg"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272337098.jpg"alt="Screenshot_2023-07-27-23-36-20-213_com.mihoyo.hyp" /></a></p><p><strong>3、扫码之后并且得到下面的结果即绑定stoken和cookie全部成功！</strong></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272349944.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272349944.png"alt="image-20230727234929884" /></a></p><h3id="方法二有点复杂不太推荐token绑定法">2、方法二（有点复杂，不太推荐）：token绑定法</h3><p><strong>1、下载群文件里面的软件</strong></p><p>群文件这个文件夹里面的软件</p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272340216.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272340216.png"alt="image-20230727234022163" /></a></p><p><strong>2、打开该软件，并且登录账户</strong><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272342268.jpg"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272342268.jpg"alt="Screenshot_2023-07-27-23-41-14-001_com.miui.home-" /></a></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272343208.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272343208.png"alt="image-20230727234310153" /></a></p><p><strong>3、点击右上角三点进行获取token并全选复制</strong></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272344671.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272344671.png"alt="image-20230727234402619" /></a></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280017637.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280017637.png"alt="image-20230728001748561" /></a></p><p><strong>4、私聊发送给机器人</strong></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280018127.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280018127.png"alt="img" /></a></p><p><strong>5、按照给的提示功能面板发送#刷新ck，抽卡记录就是#更新抽卡记录（对应的查询就是，限定池#角色记录，武器池#武器记录，常驻池#常驻记录）</strong></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272347421.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272347421.png"alt="image-20230727234715364" /></a></p><p>显示上图就说明绑定完成啦！此时喵喵面板大部分功能全部都可以进行使用了！</p><h2 id="五一些相关补充">五、一些相关补充</h2><p>这里总结的介绍下机器人的大部分插件名字，方便可以发出正确的插件面板帮助指令</p><table><thead><tr><th>插件名字</th><th>帮助指令</th></tr></thead><tbody><tr><td>喵喵插件</td><td>#喵喵帮助（#帮助）</td></tr><tr><td>土块插件</td><td>#土块帮助</td></tr><tr><td>图鉴插件</td><td>#图鉴帮助</td></tr><tr><td>枫叶插件</td><td>#枫叶帮助</td></tr><tr><td>星铁插件</td><td>#星铁帮助</td></tr><tr><td>chatgpt插件</td><td>#chatgpt帮助</td></tr><tr><td>闲心插件</td><td>#闲心帮助</td></tr><tr><td>椰奶插件</td><td>#椰奶帮助</td></tr></tbody></table><p>这些就是对应大部分插件的的帮助指令了，通过输入对应的指令就可以得到对应的功能帮助面板服务，下面还要介绍一个很常用的功能就是原神面板服务了！</p><h2 id="原神面板服务">1、原神面板服务</h2><p>原神的面板服务是基于喵喵插件的一个功能，可以再功能图就可以看到对应的一些指令。</p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272357860.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272357860.png"alt="image-20230727235755745" /></a></p><p>首先要想使用这个插件里面的面板服务的话，首先需要确认你游戏里面的资料板上面的你想要看的角色是否公开了面板，如下操作所所示</p><p><strong>1、确认游戏内已经公开你想要查询的角色面板</strong></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280000677.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280000677.png"alt="image-20230728000035486" /></a></p><p><strong>右下角的显示角色详细一定要打开</strong>，展示的话就是你想要查询角色的面板。</p><p><strong>2、向机器人绑定你的游戏uid</strong></p><p>在前面绑定cookie的帮助局域栏的右边有个#绑定uid{你的uid}这个功能，就是对应激活这个功能的指令，比如我的游戏uid是110776530，那么操作如下</p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280003331.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280003331.png"alt="image-20230728000303269" /></a></p><p><strong>3、发送#更新面板来进行获取</strong></p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280003437.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280003437.png"alt="image-20230728000348342" /></a></p><p>可以看到角色名字左边有个绿色圈圈就代表此角色面板已经更新，不过要<strong>注意这个面板更新的话如果此时刚刚好刚给角色换了圣遗物需要查看新圣遗物下角色的提升和分数就需要隔个5分钟左右更新，不然数据是不会更新的，更新成功的判断条件就是角色左边有个<code>小绿圈圈</code></strong></p><p><strong>4、发送#{角色名}面板来查询对应角色面板</strong></p><p>比如我要查纳西妲的面板就发送#纳西妲面板</p><p><ahref="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280007949.png"><imgsrc="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280007949.png"alt="image-20230728000756873" /></a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 云崽 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
